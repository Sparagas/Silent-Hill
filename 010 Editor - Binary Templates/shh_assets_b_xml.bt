//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: shh_assets_b_xml.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Version: 0.0
//   Purpose: Parse Silent Hill: Homecoming binary assets XML for Microsoft - Windows, Microsoft - Xbox 360 and Sony - PlayStation 3
//  Camagicory: 
// File Mask: assets_*_b.xml
//  ID Bytes: EE 14 5E A5
//   History: 
//   0.0   2025-01-01 Laurynas Zubavičius : Initial version.
//------------------------------------------------

// --- Structures ---

typedef struct _Header
{
    uint32 magic        <format=hex>;
                        Assert(magic == 0xA55E14EE);
    uint32 pad;
    int32  folderCount;
    int32  fileCount;
} s_Header;


typedef struct _Folder
{
    uint32 magic              <format=hex>;
                              Assert(magic == 0xA55E1D14);
    char   name[32];
    uint16 fileCount;
    int32  parentFolderIndex;
} s_Folder                    <read=name, optimize = true>;


typedef struct _FileNamesHeader
{
    uint32 magic                 <format=hex>;
                                 Assert(magic == 0xA55E1F14);
    int32  size                  <comment="Size of the raw string block">;
} s_FileNamesHeader;


typedef struct _File
{
    uint32 magic           <format=hex>;
                           Assert(magic == 0xA55E1F7E);
    uint32 fileName_offset <format=hex, comment="Offset relative to File Name Table">;
    uint32 unkMagic        <format=hex>;
    int32  folderIdx       <comment="Index into Folders array">;
} s_File                   <optimize=true, read=ReadFile>;


string GetFullPath(int folderIdx)
{  
    string name = folder[folderIdx].name;
    int parent = folder[folderIdx].parentFolderIndex;

    if (parent != -1 && parent != folderIdx) {
        return GetFullPath(parent) + "/" + name;
    }
    return name;
}


string ReadFile(s_File &f)
{
    string path = GetFullPath(f.folderIdx);
    string baseName = ReadString(startof(fileName_array[0]) + f.fileName_offset);
    string extension = parentof(f).ext;
    return path + "/" + baseName + extension;
}

//------------------------------------------------

typedef struct _FileGroup {
    uint32 magic <format=hex>;
    Assert(magic == 0xA55E1546);
    char   ext[16] <comment="File Extension">;
    char   descr[32] <comment="Description">;
    uint16 index <comment="start index into filename table">;

    if (groupIndex == 0 || index != 0) {
        int32 count;
        s_File file[count] <warn=false>;
    }
} s_FileGroup <read=ReadFileGroup>;


string ReadFileGroup(s_FileGroup &g) {
    if (g.ext != "") return g.ext + " (" + g.descr + ")";
    return "Unknown Group";
}


typedef struct _FileName_array
{
    string fileName;
} s_FileName_array <optimize=false, read=fileName>;


typedef struct _FileGroup_array
{
    for (int groupIndex = 0; !FEof(); groupIndex++) {
        if (ReadUInt() == 0xA55E1F00) {
            uint32 eofMarker <format=hex>;
            break;
        }
        s_FileGroup fileGroup;
    }
} s_FileGroup_array <read=groupIndex>;

// --- Main Parsing Logic ---

SetBackColor(cLtGray);
s_Header header;

SetBackColor(cLtYellow);
s_Folder folder[header.folderCount];

SetBackColor(cLtGreen);
s_FileNamesHeader fileNamesHeader;

SetBackColor(cAqua);
s_FileName_array fileName_array[header.fileCount];
Assert(FTell() - startof(fileName_array[0]) == fileNamesHeader.size);

SetBackColor(cLtPurple);
s_FileGroup_array fileGroup_array;
