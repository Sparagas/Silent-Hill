//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: shh_assets_b_xml.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Version: 0.0
//   Purpose: Parse Silent Hill: Homecoming binary assets XML for Microsoft - Windows, Microsoft - Xbox 360 and Sony - PlayStation 3
//  Camagicory: 
// File Mask: assets_*_b.xml
//  ID Bytes: EE 14 5E A5
//   History: 
//   0.0   2025-01-01 Laurynas Zubavičius : Initial version.
//------------------------------------------------

// --- Structures ---

typedef struct _Header
{
    uint32 magic        <format=hex>;
                        Assert(magic == 0xA55E14EE);
    uint32 padding;
    int32  folderCount;
    int32  fileCount;
} s_Header;


typedef struct _Folder
{
    uint32 magic                <format=hex>;
                                Assert(magic == 0xA55E1D14);
    char   name[32];
    uint16 fileCount;
    int32  parentFolderIndex;   
} s_Folder                      <read=name, optimize = true>;


typedef struct _FileNamesHeader
{
    uint32 magic    <format=hex>;
                    Assert(magic == 0xA55E1F14);
    int32  size     <comment="Size of the raw string block">;
} s_FileNamesHeader;


typedef struct _File
{
    uint32 magic            <format=hex>;
                            Assert(magic == 0xA55E1F7E);
    uint32 fileName_offset  <format=hex, comment="Offset relative to File Name Array">;
    uint32 unkMagic         <format=hex>;
    int32  folderIndex;
} s_File                    <optimize=true, read=ReadFile>;


string GetFullPath(int folderIndex)
{  
    string name   = folder[folderIndex].name;
    int    parent = folder[folderIndex].parentFolderIndex;

    if (parent != -1 && parent != folderIndex)
        return GetFullPath(parent) + "/" + name;
    return name;
}


string ReadFile(s_File &f)
{
    string path = GetFullPath(f.folderIndex);
    string baseName = ReadString(startof(fileName_array[0]) + f.fileName_offset);
    string fileExtensionension = parentof(f).fileExtension;
    return path + "/" + baseName + fileExtensionension;
}

//------------------------------------------------

typedef struct _FileGroup {
    uint32 magic                <format=hex>;
                                Assert(magic == 0xA55E1546);
    char   fileExtension[16]    <comment="File Extension">;
    char   description[32];
    uint16 fileNameIndex        <comment="index into File Name Array">;

    if (groupIndex == 0 || fileNameIndex != 0) {
        int32 count;
        s_File file[count]      <warn=false>;
    }
} s_FileGroup                   <read=ReadFileGroup>;


string ReadFileGroup(s_FileGroup &g) {
    if (g.fileExtension != "")
        return g.fileExtension + " (" + g.description + ")";
    return "Unknown Group";
}


typedef struct _FileName_array
{
    string fileName;
} s_FileName_array <optimize=false, read=fileName>;


typedef struct _FileGroup_array
{
    for (int groupIndex = 0; !FEof(); groupIndex++) {
        if (ReadUInt() == 0xA55E1F00) {
            uint32 eofMarker <format=hex>;
            break;
        }
        s_FileGroup fileGroup;
    }
} s_FileGroup_array <read=groupIndex>;

// --- Main Parsing Logic ---

SetBackColor(cLtGray);
s_Header header;

SetBackColor(cLtYellow);
s_Folder folder[header.folderCount];

SetBackColor(cLtGreen);
s_FileNamesHeader fileNamesHeader;

SetBackColor(cAqua);
s_FileName_array fileName_array[header.fileCount];
Assert(FTell() - startof(fileName_array[0]) == fileNamesHeader.size);

SetBackColor(cLtPurple);
s_FileGroup_array fileGroup_array;
