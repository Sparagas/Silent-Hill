//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: sh1_model.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Version: 0.0
//   Purpose: Parse Silent Hill (1) 3D models for Sony - PlayStation. *.ILM are skeletal models, *.IPD are local, and *.PLM are global static models.
//  Category: CAD
// File Mask: *.ILM, *.IPD, *.PLM
//  ID Bytes: 
//   History: 
//   0.0   2025-01-01 Laurynas Zubavičius : Initial version.
//------------------------------------------------


//------------------------------------------------
// Structs
//------------------------------------------------

typedef struct _FsImageDesc
{
    uint8 tPage[2];
    uint8 u;
    uint8 v;
    int16 clutX;
    int16 clutY;
} s_FsImageDesc;


typedef struct DVECTOR
{
	int16 vx, vy;
} DVECTOR;


typedef struct _Normal
{
    int8  nx;
    int8  ny;
    int8  nz;
    uint8 count;
} s_Normal;


/** @brief 8-character string usually used for filenames. Can be compared via the `u32` field. */
typedef union
{
    char   str[8];
    uint32 u32[2];
} u_Filename;


/*
typedef struct _ObjPrimitive
{
    uint16 field_0;
    uint16 field_2;
    uint16 field_4;

    uint8  field_6_0 : 8;

    int8   field_6_8 : 7;
    uint8  unk_6_15  : 1;

    uint16 field_8;
    uint16 field_A;
    uint8  unk_C[8];
} s_ObjPrimitive;
*/
typedef struct _Primitive
{
    uint8  u1;
    uint8  v1;
    uint16 bits;
    uint8  u2;
    uint8  v2;
    uint16 bits;
    uint8  u3;
    uint8  v3;
    uint8  u4;
    uint8  v4;
    uint8  face1;
    uint8  face2;
    uint8  face3;
    uint8  face4;
    uint8  unk_10[4];
} s_Primitive;


typedef struct _MeshHeader
{
    uint8 primitiveCount_0;
    uint8 vertexCount_1;
    uint8 normalCount_2;
    uint8 unkCount_3;

    uint32 primitivesPtr_4 <format=hex, comment="s_Primitive*">;
    uint32 vertexXyPtr_8   <format=hex, comment="DVECTOR*">;
    uint32 vertexZPtr_C    <format=hex, comment="s16*">;
    uint32 normalsPtr_10   <format=hex, comment="s_Normal*">;
    uint32 unkPtr_14       <format=hex, comment="u8*">;
} s_MeshHeader;


typedef struct _ModelHeader
{
    char       modelName_0[8];
    uint8      meshCount_8;
    uint8      vertexOffset_9;
    uint8      normalOffset_A;
    uint8      field_B_0 : 1;
    uint8      field_B_1 : 3;
    uint8      field_B_4 : 2;
    uint8      unk_B_6   : 2;
    uint32     meshHeadersPtr_C <format=hex, comment="s_MeshHeader*">;
} s_ModelHeader;

// Individual texture data.
typedef struct _Material_8
{
    s_FsImageDesc imageDesc_0;
    char          textureName_8[8];
    uint32        queueIdx_10;
    int8          field_14;
} s_Material_8;


typedef struct _Material
{
    char       materialName_0[8];
    uint32     fieldPtr_8 <format=hex, comment="s_Material_8*">;
    uint8      field_C;
    uint8      unk_D[1];
    uint8      field_E;
    uint8      field_F;
    uint16     field_10;
    uint16     field_12;
    union
    {
        uint8  u8[2];
        uint16 u16;
    } field_14;
    union
    {
        uint8  u8[2];
        uint16 u16;
    } field_16;
} s_Material;


typedef struct _LmHeader
{
    uint8  magic_0;
    Assert(magic_0 == 0x30);
    uint8  version_1;
    Assert(version_1 == 6);
    uint8  isLoaded_2;
    uint8  materialCount_3;
    uint32 materialsPtr_4  <format=hex, comment="s_Material*">;
    uint8  modelCount_8;
    uint8  unk_9[3];
    uint32 modelHeadersPtr_C <format=hex, comment="s_ModelHeader*">;
    uint32 modelOrderPtr_10  <format=hex, comment="u8*">;
    // File header ends, extra data below. Might be separate from this struct?
    //int8   unk_11[4075];
    //int32  queueIdx_1000;
} s_LmHeader;


 typedef struct s_IpdCollisionData_10
 {
    int16  field_0;
    int16  field_2;
    int16  field_4;
    uint16 field_6_0  : 5; // TODO: Might be using `s_IpdColData_18` substruct here? Won't fit though.
    uint16 field_6_5  : 3;
    uint16 field_6_8  : 3;
    uint16 field_6_11 : 4;
    uint16 field_6_15 : 1;
    int16  field_8;
    int16  field_A;
} s_IpdCollisionData_10;


typedef struct _IpdCollisionData_18
{
    uint16 field_0_0  : 5;
    uint16 field_0_5  : 3;
    uint16 field_0_8  : 3;
    uint16 field_0_11 : 4;
    uint16 field_0_15 : 1;
    uint16 field_2;
    uint16 field_4;
    uint16 field_6;
    uint16 field_8;
} s_IpdCollisionData_18;


typedef struct _IpdCollisionData
{
    int32  posX_0;
    int32  posZ_4;
    uint32 field_8_0  : 8;
    uint32 field_8_8  : 8;
    uint32 field_8_16 : 8;
    uint32 field_8_24 : 8;
    uint32 ptr_C           <format=hex, comment="void*">;
    uint32 ptr_10          <format=hex, comment="s__IpdCollisionData_10*">;
    uint32 ptr_14          <format=hex, comment="void*">;
    uint32 ptr_18          <format=hex, comment="s__IpdCollisionData_18*">;
    int16  field_1C;
    uint8  field_1E;
    uint8  field_1F;
    uint32 ptr_20          <format=hex, comment="s32*">; // Might point to `s_func_8006B1C8`?
    uint16 field_24;                                     // field_24/field_26 defined in ipd2obj but haven't seen used yet, might be size of `ptr_28`/`ptr_2C`.
    uint16 field_26;
    uint32 ptr_28          <format=hex, comment="u8*">;
    uint32 ptr_2C          <format=hex, comment="void*">;
    uint8  field_30;
    uint8  unk_31[3];
    uint8  field_34[256];
} s_IpdCollisionData;

typedef struct _IpdModelBuffer_C
{
    uint32 objList_0 <format=hex, comment="s_ModelHeader*">;
    uint8  unk_4[32];
} s_IpdModelBuffer_C;

typedef struct _IpdModelBuffer
{
    uint8  field_0; // Count of `field_C` entries.
    uint8  unk_1[3];
    uint8  unk_4[8];
    uint32 fieldPtr_C  <format=hex, comment="s_IpdModelBuffer_C*">;
    uint32 fieldPtr_10 <format=hex, comment="void*">; // Pointer to unknown collision data.
    uint32 fieldPtr_14 <format=hex, comment="void*">; // Pointer to unknown collision data.
} s_IpdModelBuffer;


typedef struct _IpdModelInfo
{
    uint8      isGlobalPlm_0; // `false` if loaded from inside IPD, `true` if loaded from `*_GLB.PLM`
    uint8      unk_1[3];
    char       modelName_4[8];
    uint32     objListPtr_C    <format=hex, comment="s_ModelHeader*">;
} s_IpdModelInfo;

typedef struct _IpdHeader
{
    uint8              magic_0;
    Assert ( magic_0 == 0x14 );
    uint8              isLoaded_1; /** `bool` */
    int8               levelGridX_2;
    int8               levelGridY_3;
    uint32             lmHeaderPtr_4        <format=hex, comment="s_LmHeader*">;
    uint8              modelCount_8;
    uint8              modelBufferCount_9;
    uint8              modelOrderCount_A;
    uint8              unk_B[1];
    uint8              unk_C[8];
    uint32             modelInfoPtr_14      <format=hex, comment="s_IpdModelInfo**">;
    uint32             modelBuffersPtr_18   <format=hex, comment="s_IpdModelBuffer*">;
    uint8              textureCount_1C;                   // Should it be `u32`?
                                                          // "`u8` - Relative pointer to textures list"
                                                          // "`u32` - Relative pointer to object order"
    uint8              unk_1D[3];
    uint8              unk_20[48];
    uint32             modelOrderPtr_50 <format=hex, comment="u8*">;
    s_IpdCollisionData collisionData_54;
} s_IpdHeader;

//------------------------------------------------

struct MeshBuffer
{
    FSeek       ( meshHeaders_C[j].primitivesPtr_4 );
    s_Primitive primitives [ meshHeaders_C[j].primitiveCount_0 ];
    
    FSeek   ( meshHeaders_C[j].vertexXyPtr_8 );
    DVECTOR verticesXy [ meshHeaders_C[j].vertexCount_1 ];
    
    FSeek ( meshHeaders_C[j].vertexZPtr_C );
    int16 verticesZ [ meshHeaders_C[j].vertexCount_1 ];

    FSeek    ( meshHeaders_C[j].normalsPtr_10 );
    s_Normal normals [ meshHeaders_C[j].normalCount_2 ];

    FSeek ( meshHeaders_C[j].unkPtr_14 );
    ubyte unkIdx [ meshHeaders_C[j].unkCount_3 ];
};

struct MeshBuffers
{
    for ( int j = 0; j < modelHeaders[i].meshCount_8; j++ )
    {
	    FSeek      ( meshHeaders_C[j].primitivesPtr_4 );
        MeshBuffer meshBuffer;
    };
};

struct Model
{
    FSeek       ( modelHeaders[i].meshHeadersPtr_C );
    s_MeshHeader meshHeaders_C [ modelHeaders[i].meshCount_8 ];

    FSeek       ( meshHeaders_C.primitivesPtr_4 );
    MeshBuffers meshBuffers;
};

struct Models
{
    for (int i = 0; i < lmHeader.modelCount_8; i++ )
    {
        FSeek ( modelHeaders[i].meshHeadersPtr_C );
        Model model;
    };
};

//------------------------------------------------

struct IPD_PART
{
    s_IpdHeader ipdHeader;

    FSeek          ( ipdHeader.modelInfoPtr_14 );
    s_IpdModelInfo modelInfo [ ipdHeader.modelCount_8 ];
    
    FSeek            ( ipdHeader.modelBuffersPtr_18 );
    s_IpdModelBuffer modelBuffer [ ipdHeader.modelBufferCount_9 ];

    FSeek          ( ipdHeader.lmHeaderPtr_4 );  
    OffsetSetStart ( FTell() );
};

struct LM_PART
{
    s_LmHeader lmHeader; 

    FSeek      ( lmHeader.materialsPtr_4 );
    s_Material material [ lmHeader.materialCount_3 ];
    
    FSeek         ( lmHeader.modelHeadersPtr_C );
    s_ModelHeader modelHeaders [ lmHeader.modelCount_8 ];
    
    //struct PADDING {
    //    byte pad;
    //} padding [ lmHeader.modelCount_8 ];
    
    FSeek ( lmHeader.modelOrderPtr_10 );
    uint8 modelsOrder [ lmHeader.modelCount_8 ];
    
    FSeek  ( modelHeaders.meshHeadersPtr_C );
    Models models;
};


//------------------------------------------------
// Main
//------------------------------------------------


if (ReadShort() == 0x14)
    IPD_PART ipdPart <open=true>;

LM_PART lmPart <open=true>;
