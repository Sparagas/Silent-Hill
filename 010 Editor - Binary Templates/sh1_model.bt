//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: sh1_model.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Version: 0.0
//   Purpose: Parse Silent Hill (1) 3D models for Sony - PlayStation. *.ILM are skeletal models, *.IPD are local, and *.PLM are global static models.
//  Category: CAD
// File Mask: *.ILM, *.IPD, *.PLM
//  ID Bytes: 
//   History: 
//   0.0   2025-01-01 Laurynas Zubavičius : Initial version.
//------------------------------------------------


//------------------------------------------------
// Structs
//------------------------------------------------

typedef struct {
    //int16 m[3][3]; /* 3x3 rotation matrix */
    int16 m[3 * 3]; /* 3x3 rotation matrix */
    uint8 _pad[2];
    int32 t[3];    /* transfer vector */
} MATRIX;


typedef struct _FsImageDesc
{
    uint8 tPage[2];
    uint8 u;
    uint8 v;
    int16 clutX;
    int16 clutY;
} s_FsImageDesc;


typedef struct DVECTOR
{
	int16 vx, vy;
} DVECTOR;

/** @brief Smaller `SVECTOR` with padding removed. Used for fixed-point rotations. */
typedef struct
{
    int16 vx;
    int16 vy;
    int16 vz;
} SVECTOR3;

typedef struct _Normal
{
    int8  nx;
    int8  ny;
    int8  nz;
    uint8 count;
} s_Normal;


/** @brief 8-character string usually used for filenames. Can be compared via the `u32` field. */
typedef union
{
    char   str[8];
    uint32 u32[2];
} u_Filename;


/*
typedef struct _ObjPrimitive
{
    uint16 field_0;
    uint16 field_2;
    uint16 field_4;

    uint8  field_6_0 : 8;

    int8   field_6_8 : 7;
    uint8  unk_6_15  : 1;

    uint16 field_8;
    uint16 field_A;
    uint8  unk_C[8];
} s_ObjPrimitive;
*/
typedef struct _Primitive
{
    uint8  u1;
    uint8  v1;
    uint16 bits;
    uint8  u2;
    uint8  v2;
    uint16 bits;
    // uint8 field_6_0  : 8;
    // int8  field_6_8  : 7;
    // uint8 field_6_15 : 1; // `bool`
    uint8  u3;
    uint8  v3;
    uint8  u4;
    uint8  v4;
    uint8  face1;
    uint8  face2;
    uint8  face3;
    uint8  face4;
    uint8  unk_10[4];
} s_Primitive;


typedef struct _MeshHeader
{
    uint8 primitiveCount_0;
    uint8 vertexCount_1;
    uint8 normalCount_2;
    uint8 unkCount_3;

    uint32 primitivesPtr_4 <format=hex, comment="s_Primitive*">;
    uint32 vertexXyPtr_8   <format=hex, comment="DVECTOR*">;
    uint32 vertexZPtr_C    <format=hex, comment="s16*">;
    uint32 normalsPtr_10   <format=hex, comment="s_Normal*">;
    uint32 unkPtr_14       <format=hex, comment="u8*">;
} s_MeshHeader;


typedef struct _ModelHeader
{
    char   modelName_0[8];
    uint8  meshCount_8;
    uint8  vertexOffset_9;
    uint8  normalOffset_A;
    uint8  field_B_0 : 1;
    uint8  field_B_1 : 3;
    uint8  field_B_4 : 2;
    uint8  unk_B_6   : 2;
    uint32 meshHeadersPtr_C <format=hex, comment="s_MeshHeader*">;
} s_ModelHeader;

// Individual texture data.
typedef struct _Material_8
{
    s_FsImageDesc imageDesc_0;
    char          textureName_8[8];
    uint32        queueIdx_10;
    int8          refCount_14;
} s_Texture;


typedef struct _Material
{
    char       name_0[8];
    uint32     texPtr_8 <format=hex, comment="s_Texture*">;
    uint8      field_C;
    uint8      unk_D[1];
    uint8      field_E;
    uint8      field_F;
    uint16     field_10;
    uint16     field_12;
    union
    {
        uint8  u8[2];
        uint16 u16;
    } field_14;
    union
    {
        uint8  u8[2];
        uint16 u16;
    } field_16;
} s_Material;


typedef struct _LmHeader
{
    uint8  magic_0;
    Assert(magic_0 == 0x30);
    uint8  version_1;
    Assert(version_1 == 6);
    uint8  isLoaded_2;
    uint8  materialCount_3;
    uint32 materialsPtr_4  <format=hex, comment="s_Material*">;
    uint8  modelCount_8;
    uint8  unk_9[3];
    uint32 modelHeadersPtr_C <format=hex, comment="s_ModelHeader*">;
    uint32 modelOrderPtr_10  <format=hex, comment="u8*">;
    // File header ends, extra data below. Might be separate from this struct?
    //int8   unk_11[4075];
    //int32  queueIdx_1000;
} s_LmHeader;


 typedef struct s_IpdCollisionData_10
 {
    int16  field_0;
    int16  field_2;
    int16  field_4;
    uint16 field_6_0  : 5; // TODO: Might be using `s_IpdColData_18` substruct here? Won't fit though.
    uint16 field_6_5  : 3;
    uint16 field_6_8  : 3;
    uint16 field_6_11 : 4;
    uint16 field_6_15 : 1;
    int16  field_8;
    int16  field_A;
} s_IpdCollisionData_10;

typedef struct
{
    int16  field_0_0  : 14;
    uint16 field_0_14 : 2;
    uint16 field_2_0  : 14;
    uint16 field_2_14 : 2;
    int16  field_4;
    uint8  field_6;
    uint8  field_7;
    uint8  field_8;
    uint8  field_9;
} s_IpdCollisionData_14;

typedef struct
{
    int16 field_0;
    int8  unk_2[2];
} s_IpdCollisionData_20;

typedef struct _IpdCollisionData_18
{
    uint16   field_0_0  : 5;
    uint16   field_0_5  : 3;
    uint16   field_0_8  : 4;
    uint16   field_0_12 : 3;
    uint16   field_0_15 : 1;
    SVECTOR3 vec_2;
    uint16   field_8;
} s_IpdCollisionData_18;


typedef struct _IpdCollisionData
{
    int32  posX_0;
    int32  posZ_4;
    uint32 field_8_0  : 8;
    uint32 field_8_8  : 8;
    uint32 field_8_16 : 8;
    uint32 field_8_24 : 8;
    uint32 ptr_C           <format=hex, comment="SVECTOR3*">;
    uint32 ptr_10          <format=hex, comment="s_IpdCollisionData_10*">;
    uint32 ptr_14          <format=hex, comment="s_IpdCollisionData_14*">;
    uint32 ptr_18          <format=hex, comment="s_IpdCollisionData_18*">;
    int16  field_1C;
    uint8  field_1E;
    uint8  field_1F;
    uint32 ptr_20          <format=hex, comment="s_IpdCollisionData_20*">;
    uint16 field_24; // `field_24/``field_26` defined in ipd2obj but haven't seen used yet, might be size of `ptr_28`/`ptr_2C`.
    uint16 field_26;
    uint32 ptr_28          <format=hex, comment="u8*">;
    uint32 ptr_2C          <format=hex, comment="void*">;
    uint8  field_30;
    uint8  unk_31[3];
    uint8  field_34[256];
} s_IpdCollisionData;

typedef struct _IpdModelBuffer_C
{
    uint32 modelHeader_0 <format=hex, comment="s_ModelHeader*">;
    MATRIX field_4;
} s_IpdModelBuffer_C;

typedef struct _IpdModelBuffer
{
    uint8  field_0; // Count of `field_C` entries.
    uint8  field_1;
    uint8  field_2;
    int8   unk_3;
    int16  field_4;
    int16  field_6;
    int16  field_8;
    int16  field_A;
    uint32 fieldPtr_C  <format=hex, comment="s_IpdModelBuffer_C*">;
    uint32 fieldPtr_10 <format=hex, comment="SVECTOR*">; // Pointer to unknown collision data, type assumed.
    uint32 fieldPtr_14 <format=hex, comment="SVECTOR*">; // Pointer to unknown collision data, type assumed.
} s_IpdModelBuffer;


typedef struct _IpdModelInfo
{
    uint8      isGlobalPlm_0; // `false` if loaded from inside `IPD`, `true` if loaded from `*_GLB.PLM`.
    uint8      unk_1[3];
    char       modelName_4[8];
    uint32     modelHeaderPtr_C <format=hex, comment="s_ModelHeader*">;
} s_IpdModelInfo;

typedef struct _IpdHeader
{
    uint8              magic_0;
    Assert ( magic_0 == 0x14 );
    uint8              isLoaded_1; /** `bool` */
    int8               levelGridX_2;
    int8               levelGridY_3;
    uint32             lmHeaderPtr_4        <format=hex, comment="s_LmHeader*">;
    uint8              modelCount_8;
    uint8              modelBufferCount_9;
    uint8              modelOrderCount_A;
    uint8              unk_B[1];
    uint8              unk_C[8];
    uint32             modelInfoPtr_14      <format=hex, comment="s_IpdModelInfo*">;
    uint32             modelBuffersPtr_18   <format=hex, comment="s_IpdModelBuffer*">;
    uint8              textureCount_1C;                   // Should it be `u32`?
                                                          // "`u8` - Relative pointer to textures list"
                                                          // "`u32` - Relative pointer to object order"
    uint8              unk_1D[3];
    uint8              unk_20[48];
    uint32             modelOrderPtr_50 <format=hex, comment="u8*">;
    s_IpdCollisionData collisionData_54;
} s_IpdHeader;

//------------------------------------------------

struct MeshBuffer
{
    #define J meshHeaders_C[j]

    FSeek       ( J.primitivesPtr_4 );
    s_Primitive primitives [ J.primitiveCount_0 ];

    FSeek   ( J.vertexXyPtr_8 );
    DVECTOR verticesXy [ J.vertexCount_1 ];

    FSeek ( J.vertexZPtr_C );
    int16 verticesZ [ J.vertexCount_1 ];

    FSeek    ( J.normalsPtr_10 );
    s_Normal normals [ J.normalCount_2 ];

    FSeek ( J.unkPtr_14 );
    ubyte unkIdx [ J.unkCount_3 ];
};

struct MeshBuffers
{
    for ( int j = 0; j < modelHeaders[i].meshCount_8; j++ )
    {
	    FSeek      ( J.primitivesPtr_4 );
        MeshBuffer meshBuffer;
    };
};

struct Model
{
    FSeek       ( modelHeaders[i].meshHeadersPtr_C );
    s_MeshHeader meshHeaders_C [ modelHeaders[i].meshCount_8 ];

    FSeek       ( meshHeaders_C.primitivesPtr_4 );
    MeshBuffers meshBuffers;
};

struct Models
{
    for (int i = 0; i < lmHeader.modelCount_8; i++ )
    {
        FSeek ( modelHeaders[i].meshHeadersPtr_C );
        Model model;
    };
};

//------------------------------------------------

struct IPD_PART
{
    s_IpdHeader ipdHeader;

    FSeek          ( ipdHeader.modelInfoPtr_14 );
    s_IpdModelInfo modelInfo [ ipdHeader.modelCount_8 ];
    
    FSeek            ( ipdHeader.modelBuffersPtr_18 );
    s_IpdModelBuffer modelBuffer [ ipdHeader.modelBufferCount_9 ];

    struct IpdModelBuffers {
        for (int i; i < ipdHeader.modelBufferCount_9; i++)
        {
            struct {
                FSeek( modelBuffer[i].fieldPtr_C );
                s_IpdModelBuffer_C field_C[modelBuffer[i].field_0];
                
                FSeek( modelBuffer[i].fieldPtr_10 );
                SVECTOR3 field_10;
                
                FSeek( modelBuffer[i].fieldPtr_14 );
                SVECTOR3 field_14;
            } IpdModelBuffer;
        }
    } ipdModelBuffers;

    FSeek          ( ipdHeader.lmHeaderPtr_4 );  
    OffsetSetStart ( FTell() );
};

struct LM_PART
{
    s_LmHeader lmHeader; 

    FSeek      ( lmHeader.materialsPtr_4 );
    s_Material material [ lmHeader.materialCount_3 ];
    
    FSeek         ( lmHeader.modelHeadersPtr_C );
    s_ModelHeader modelHeaders [ lmHeader.modelCount_8 ];
    
    //struct PADDING {
    //    byte pad;
    //} padding [ lmHeader.modelCount_8 ];
    
    FSeek ( lmHeader.modelOrderPtr_10 );
    uint8 modelsOrder [ lmHeader.modelCount_8 ];
    
    FSeek  ( modelHeaders.meshHeadersPtr_C );
    Models models;
};


//------------------------------------------------
// Main
//------------------------------------------------


if (ReadShort() == 0x14)
    IPD_PART ipdPart <open=true>;

LM_PART lmPart <open=true>;
