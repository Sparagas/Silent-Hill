//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: sh1_model.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Version: 0.0
//   Purpose: Parse Silent Hill (1) 3D models for Sony - PlayStation. *.ILM are skeletal models, *.IPD are local, and *.PLM are global static models.
//  Category: CAD
// File Mask: *.ILM, *.IPD, *.PLM
//  ID Bytes: 
//   History: 
//   0.0   2025-01-01 Laurynas Zubavičius : Initial version.
//------------------------------------------------


//------------------------------------------------
// In-line Structs
//------------------------------------------------

typedef struct {
    int16 m[3 * 3]; /* 3x3 rotation matrix */
    FSkip(2);
    int32 t[3];     /* transfer vector */
} MATRIX;


typedef struct DVECTOR
{
	int16 vx, vy;
} DVECTOR;

typedef struct _FsImageDesc
{
    uint8 tPage[2];
    uint8 u;
    uint8 v;
    int16 clutX;
    int16 clutY;
} s_FsImageDesc;

/** @brief Smaller `SVECTOR` with padding removed. Used for fixed-point rotations. */
typedef struct
{
    int16 vx;
    int16 vy;
    int16 vz;
} SVECTOR3;

typedef struct _Normal
{
    int8  nx;
    int8  ny;
    int8  nz;
    uint8 count;
} s_Normal;


/** @brief 8-character string usually used for filenames. Can be compared via the `u32` field. */
typedef union _Filename
{
    char   str[8];
    uint32 u32[2];
} u_Filename;


/*
typedef struct _ObjPrimitive
{
    uint16 field_0;
    uint16 field_2;
    uint16 field_4;

    uint8  field_6_0 : 8;

    int8   field_6_8 : 7;
    uint8  unk_6_15  : 1;

    uint16 field_8;
    uint16 field_A;
    uint8  unk_C[8];
} s_ObjPrimitive;
*/
typedef struct _Primitive
{
    uint8  u1;
    uint8  v1;
    uint16 bits;
    uint8  u2;
    uint8  v2;
    uint16 bits;
    // uint8 field_6_0  : 8;
    // int8  field_6_8  : 7;
    // uint8 field_6_15 : 1; // `bool`
    uint8  u3;
    uint8  v3;
    uint8  u4;
    uint8  v4;
    uint8  face1;
    uint8  face2;
    uint8  face3;
    uint8  face4;
    uint8  unk_10[4];
} s_Primitive;


typedef struct _MeshHeader
{
    uint8 primitiveCount_0;
    uint8 vertexCount_1;
    uint8 normalCount_2;
    uint8 unkCount_3;

    uint32      primitives_4_Offset <format=hex, comment="s_Primitive*">;
    s_Primitive primitives_4_Data [ primitiveCount_0 ] <pos=(primitives_4_Offset+OffsetStart), optimize=true>;
    
    uint32      vertexXy_8_Offset   <format=hex, comment="DVECTOR*">;
    DVECTOR     vertexXy_8_Data [ vertexCount_1 ] <pos=(vertexXy_8_Offset+OffsetStart), optimize=true>;
    
    uint32      vertexZ_C_Offset    <format=hex, comment="int16*">;
    int16       vertexZ_C_Data [ vertexCount_1 ] <pos=(vertexZ_C_Offset+OffsetStart)>;
    
    uint32      normals_10_Offset   <format=hex, comment="s_Normal*">;
    s_Normal    normals_10_Data [ normalCount_2 ] <pos=(normals_10_Offset+OffsetStart), optimize=true>;
    
    uint32      unkPtr_14_Offset    <format=hex, comment="uint8*">;
    uint8       unkPtr_14_Data [ unkCount_3 ] <pos=(unkPtr_14_Offset+OffsetStart)>;
} s_MeshHeader;

//------------------------------------------------
// bodyprog.h#L661

typedef struct (uint8 count) {
    uint32 offset                <format=hex>;
    if (offset > 0)
        s_MeshHeader data[count] <pos=(offset+OffsetStart), optimize=true>;
    } s_MeshHeader_Ptr           <style=sMarker, read="s_MeshHeader* meshHdrs_C[meshCount_8]">;

typedef struct _ModelHeader
{
    u_Filename       name_0;
    uint8            meshCount_8;
    uint8            vertexOffset_9;
    uint8            normalOffset_A;
    uint8            field_B_0 : 1;
    uint8            field_B_1 : 3; // Value used in `func_800571D0` switch.
    uint8            field_B_4 : 2;
    uint8            unk_B_6   : 2;
    s_MeshHeader_Ptr meshHdrs_C(meshCount_8);
} s_ModelHeader <style=sHeading3>;

//------------------------------------------------
// bodyprog.h#L675

typedef struct _Texture
{
    s_FsImageDesc imageDesc_0;
    u_Filename    name_8;
    uint32        queueIdx_10;
    int8          refCount_14;
} s_Texture;

//------------------------------------------------
// bodyprog.h#L683

typedef struct {
    uint32 offset      <format=hex>;
    if (offset > 0)
        s_Texture data <pos=(offset+OffsetStart)>;
    } s_Texture_Ptr <style=sMarker, read="s_Texture* texture_8">;

typedef struct _Material
{
    u_Filename    name_0;
    s_Texture_Ptr texture_8;
    uint8         field_C;
    uint8         unk_D[1];
    uint8         field_E;
    uint8         field_F;
    uint16        field_10;
    uint16        field_12;
    union
    {
        uint8  u8[2];
        uint16 u16;
    } field_14;
    union
    {
        uint8  u8[2];
        uint16 u16;
    } field_16;
} s_Material  <style=sHeading2>;

//------------------------------------------------
// bodyprog.h#L706

typedef struct (uint8 count) {
    uint32 offset              <format=hex>;
    if (offset > 0)
        s_Material data[count] <pos=(offset+OffsetStart), optimize=true>;
    } s_Material_Ptr           <style=sMarker, read="s_Material* materials_4[materialCount_3]">;

typedef struct (uint8 count) {
    uint32 offset                 <format=hex>;
    if (offset > 0)
        s_ModelHeader data[count] <pos=(offset+OffsetStart), optimize=true>;
    } s_ModelHeader_Ptr           <style=sMarker, read="s_ModelHeader* modelHdrs_C[modelCount_8]">;

typedef struct (uint8 count) {
    uint32 offset         <format=hex>;
    if (offset > 0)
        uint8 data[count] <pos=(offset+OffsetStart)>;
    } uint8_Ptr           <style=sMarker, read="uint8* modelOrder_10[modelCount_8]">;

typedef struct _LmHeader
{
    uint8             magic_0 <style=sHeading1Accent>;    /** See `LM_HEADER_MAGIC`. */
    Assert(magic_0 == 0x30);
    uint8             version_1 <style=sHeading1Accent>;  /** See `LM_VERSION`. */
    Assert(version_1 == 6);
    uint8             isLoaded_2; /** `bool` */
    uint8             materialCount_3;
    s_Material_Ptr    materials_4(materialCount_3);
    uint8             modelCount_8;
    uint8             unk_9[3];
    s_ModelHeader_Ptr modelHdrs_C(modelCount_8);
    uint8_Ptr         modelOrder_10(modelCount_8);
    
} s_LmHeader <style=sHeading1>;

//------------------------------------------------

 typedef struct s_IpdCollisionData_10
 {
    int16  field_0;
    int16  field_2;
    int16  field_4;
    uint16 field_6_0  : 5; // TODO: Might be using `s_IpdColData_18` substruct here? Won't fit though.
    uint16 field_6_5  : 3;
    uint16 field_6_8  : 3;
    uint16 field_6_11 : 4;
    uint16 field_6_15 : 1;
    int16  field_8;
    int16  field_A;
} s_IpdCollisionData_10;

typedef struct
{
    int16  field_0_0  : 14;
    uint16 field_0_14 : 2;
    uint16 field_2_0  : 14;
    uint16 field_2_14 : 2;
    int16  field_4;
    uint8  field_6;
    uint8  field_7;
    uint8  field_8;
    uint8  field_9;
} s_IpdCollisionData_14;

typedef struct
{
    int16 field_0;
    int8  unk_2[2];
} s_IpdCollisionData_20;

typedef struct _IpdCollisionData_18
{
    uint16   field_0_0  : 5;
    uint16   field_0_5  : 3;
    uint16   field_0_8  : 4;
    uint16   field_0_12 : 3;
    uint16   field_0_15 : 1;
    SVECTOR3 vec_2;
    uint16   field_8;
} s_IpdCollisionData_18;


typedef struct _IpdCollisionData
{
    int32  positionX_0;
    int32  positionZ_4;
    uint32 field_8_0  : 8;
    uint32 field_8_8  : 8;
    uint32 field_8_16 : 8;
    uint32 field_8_24 : 8;
    uint32 ptr_C           <format=hex, comment="SVECTOR3*">;
    uint32 ptr_10          <format=hex, comment="s_IpdCollisionData_10*">;
    uint32 ptr_14          <format=hex, comment="s_IpdCollisionData_14*">;
    uint32 ptr_18          <format=hex, comment="s_IpdCollisionData_18*">;
    int16  field_1C;
    uint8  field_1E; // } Used as multipliers for `field_1C` in `func_8006B004`.
    uint8  field_1F; // }
    uint32 ptr_20          <format=hex, comment="s_IpdCollisionData_20*">;
    uint16 field_24; // `field_24/``field_26` defined in ipd2obj but haven't seen used yet, might be size of `ptr_28`/`ptr_2C`.
    uint16 field_26;
    uint32 ptr_28          <format=hex, comment="u8*">; // Accessed as array of indices into `field_34` by `func_8006E53C`.
    uint32 ptr_2C          <format=hex, comment="void*">;
    uint8  field_30;
    uint8  unk_31[3];
    uint8  field_34[256];
} s_IpdCollisionData;

typedef struct _IpdModelBuffer_C
{
    uint32 modelHdr_0 <format=hex, comment="s_ModelHeader*">;
    MATRIX field_4;
} s_IpdModelBuffer_C <style=sHeading3>;

typedef struct _IpdModelBuffer
{
    uint8  field_0; // Count of `field_C` entries.
    uint8  field_1;
    uint8  field_2;
    int8   unk_3;
    int16  field_4;
    int16  field_6;
    int16  field_8;
    int16  field_A;
    uint32 fieldPtr_C  <format=hex, comment="s_IpdModelBuffer_C*">;
    uint32 fieldPtr_10 <format=hex, comment="SVECTOR*">; // Pointer to unknown collision data, type assumed.
    uint32 fieldPtr_14 <format=hex, comment="SVECTOR*">; // Pointer to unknown collision data, type assumed.
} s_IpdModelBuffer <style=sHeading3>;


typedef struct _IpdModelInfo
{
    uint8      isGlobalPlm_0; // `false` if loaded from inside `IPD`, `true` if loaded from `*_GLB.PLM`.
    uint8      unk_1[3];
    u_Filename modelName_4;
    uint32     modelHdr_C <format=hex, comment="s_ModelHeader*">;
} s_IpdModelInfo <style=sHeading2>;

typedef struct _IpdHeader
{
    uint8              magic_0;
    Assert(magic_0 == 0x14);
    
    uint8              isLoaded_1; /** `bool` */
    int8               levelGridX_2;
    int8               levelGridY_3;
    uint32             lmHdr_4_Offset       <format=hex, comment="s_LmHeader*">;
    uint8              modelCount_8;
    uint8              modelBufferCount_9;
    uint8              modelOrderCount_A;
    uint8              unk_B[1];
    uint8              unk_C[8];
    uint32             modelInfo_14_Offset    <format=hex, comment="s_IpdModelInfo*">;
    uint32             modelBuffers_18_Offset <format=hex, comment="s_IpdModelBuffer*">;
    uint8              textureCount_1C;                   // Should it be `u32`?
                                                          // "`u8` - Relative pointer to textures list"
                                                          // "`u32` - Relative pointer to object order"
    uint8              unk_1D[3];
    uint8              unk_20[48];
    uint32             modelOrderPtr_50_Offset <format=hex, comment="u8*">;
    s_IpdCollisionData collisionData_54;
} s_IpdHeader <style=sHeading1>;

//------------------------------------------------
// Out-of-line Structs
//------------------------------------------------

typedef struct _MeshHeader_Data
{
    #define J meshHeaders_C[j]

    FSeek       ( J.primitives_4_Offset );
    s_Primitive primitives [ J.primitiveCount_0 ] <optimize=true>;

    FSeek   ( J.vertexXy_8_Offset );
    DVECTOR verticesXy [ J.vertexCount_1 ] <optimize=true>;

    FSeek ( J.vertexZ_C_Offset );
    int16 verticesZ [ J.vertexCount_1 ];

    FSeek    ( J.normals_10_Offset );
    s_Normal normals [ J.normalCount_2 ] <optimize=true>;

    FSeek ( J.unkPtr_14_Offset );
    ubyte unkIdx [ J.unkCount_3 ];
} s_MeshHeader_Data;

typedef struct _MeshHeader_DataArray
{
    for ( int j = 0; j < lmHeader_Data.modelHeaders[i].meshCount_8; j++ )
    {
	    FSeek      ( J.primitives_4_Offset );
        s_MeshHeader_Data meshHeaders_C_Data;
    };
} s_MeshHeader_DataArray;

typedef struct _ModelHeader_Data
{
    FSeek       ( lmHeader_Data.modelHeaders[i].meshHdrs_C.offset );
    s_MeshHeader meshHeaders_C [ lmHeader_Data.modelHeaders[i].meshCount_8 ] <optimize=true>;

    FSeek       ( meshHeaders_C.primitives_4_Offset );
    s_MeshHeader_DataArray meshHeaders_C_DataArray;
} s_ModelHeader_Data;

typedef struct _ModelHeader_DataArray
{
    for (int i = 0; i < lmHeader.modelCount_8; i++ )
    {
        FSeek ( lmHeader_Data.modelHeaders[i].meshHdrs_C.offset );
        s_ModelHeader_Data modelHeaders_C;
    };
} s_ModelHeader_DataArray;

typedef struct _LmHeader_Data
{
    FSeek ( lmHeader.materials_4.offset );
    s_Material materials [ lmHeader.materialCount_3 ] <optimize=true>;
    
    FSeek ( lmHeader.modelHdrs_C.offset );
    s_ModelHeader modelHeaders [ lmHeader.modelCount_8 ] <optimize=true>;
    
    // FSkip(lmHeader.modelCount_8);
    
    FSeek ( lmHeader.modelOrder_10.offset );
    uint8 modelsOrder [ lmHeader.modelCount_8 ] <style=sHeading4>;
} s_LmHeader_Data;

//------------------------------------------------

struct IPD_PART
{
    s_IpdHeader ipdHeader;

    FSeek          ( ipdHeader.modelInfo_14_Offset );
    s_IpdModelInfo modelInfo [ ipdHeader.modelCount_8 ];
    
    FSeek            ( ipdHeader.modelBuffers_18_Offset );
    s_IpdModelBuffer modelBuffer [ ipdHeader.modelBufferCount_9 ];

    struct IpdModelBuffers {
        for (int i; i < ipdHeader.modelBufferCount_9; i++)
        {
            struct {
                FSeek( modelBuffer[i].fieldPtr_C );
                s_IpdModelBuffer_C field_C[modelBuffer[i].field_0] <optimize=true>;
                
                FSeek( modelBuffer[i].fieldPtr_10 );
                SVECTOR3 field_10;
                
                FSeek( modelBuffer[i].fieldPtr_14 );
                SVECTOR3 field_14;
            } IpdModelBuffer;
        }
    } ipdModelBuffers;
};

struct LM_PART
{
    s_LmHeader      lmHeader; 
    s_LmHeader_Data lmHeader_Data;
    
    FSeek  ( lmHeader_Data.modelHeaders.meshHdrs_C.offset );
    s_ModelHeader_DataArray modelHeaders_C;
};


//------------------------------------------------
// Main
//------------------------------------------------

local uint32 OffsetStart = 0;
if (ReadShort() == 0x14)
{
    IPD_PART ipdPart <open=true>;
    
    OffsetSetStart ( ipdPart.ipdHeader.lmHdr_4_Offset );
    OffsetStart = OffsetGetStart();
    FSeek(0);
}
LM_PART lmPart <open=true>;
