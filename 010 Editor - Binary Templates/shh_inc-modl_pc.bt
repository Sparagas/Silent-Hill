//------------------------------------------------
//--- 010 Editor Binary Template
//
//      File: shh_inc-modl_pc.bt
//   Authors: Laurynas Zubavičius (Sparagas)
//   Version: 0.0
//   Purpose: Parse Silent Hill: Homecoming inc-modl file for Microsoft - Windows
//  Category: CAD
// File Mask: 
//  ID Bytes: 
//   History: 
//   0.0   2025-01-01 Laurynas Zubavičius : Initial version.
//------------------------------------------------


struct PoolDirectory {
    int32  offset;
    Assert(offset == -1);
    uint32 SubHeadCount;
    Assert(SubHeadCount == 6);
    uint32 subHeadStride;
    Assert(subHeadStride == 20);
    uint32 meshCount;
    uint32 poolSize;
    //Assert(poolTotalSize == 720);
};

struct SubHead {
    uint32 offset <format=hex>;
    ubyte  unk_00[4];
    uint32 size;
    uint32 elementCount <comment="this could be wrong">; // e.g., 21, 4, 1
    uint32 offsetIn20BytePool <comment="this could be wrong">;; // e.g., 140, 560. Steps by (elementCount * 20)
};

struct ObjectEntry {
    uint32 class_id;  
    uint32 unk1;     
    uint32 unk1;
    uint32 countOrSize; 
    uint32 offsetOrValue;
};

struct SubMeshHeader {
    uint32 magic;
    Assert(magic==0x04003000);
    FSkip(52);
    uint32 startIndex;
    uint32 triCount;
    uint32 vertCount;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 indexCount;
    uint32 unk;
    uint32 unk;
    FSkip(28);
    float boundSphereCenter[3];
    float boundSphereRadius;
    float boundBoxMin[3];
    float boundBoxMax[3];
    FSkip(12);
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
    uint32 unk;
};

struct MeshBufferMap {
    int32 vb1_Stride;
    int32 vb1_Offset;
    int32 unk;
    int32 unk;
    int32 unk;
    int32 unk;
    int32 unk;
    int32 vb2_Stride;
    int32 vb2_Offset;
    int32 unk;
    int32 unk;
    int32 unk;
    int32 unk;
    int32 unk;
};

struct BufferTopologyDat {
    uint32 num_unk;
    uint32 faces_buf_size_2;
    ubyte  unk0;
    ubyte  faces_buf_u16_or_u32;
    uint16 faces_buf_list_or_strip;
    uint32 verts_buf_size_2;
    ubyte  verts_buf_byte_mode;
    ubyte  unk1[3];
    uint32 UVs_buf_size_2;
    ubyte  UVs_buf_byte_mode;
    ubyte  unk2;
};

struct FacesU32List {
    uint32 tri_id_0;
    uint32 tri_id_1;
    uint32 tri_id_2;
};

struct FacesU16List {
    uint16 tri_id_0;
    uint16 tri_id_1;
    uint16 tri_id_2;
};

struct VertexBuffer1Dat {
    float vert_x;
    float vert_y;
    float vert_z;
    byte  normals[4];
    byte  tangents[4];
    ubyte boneWeights[4]; // or boneIndices[4], depending on if it's rigged
};

struct VertexBuffer2Channel1 {
    ubyte  r;
    ubyte  g;
    ubyte  b;
    ubyte  a;
    float  uv0_u;
    float  uv0_v;
};

struct VertexBuffer2Channel2 {
    ubyte  r;
    ubyte  g;
    ubyte  b;
    ubyte  a;
    float  uv0_u;
    float  uv0_v;
    float  uv1_u;
    float  uv1_v;
};

struct VertexBuffer2Channel3 {
    ubyte  r;
    ubyte  g;
    ubyte  b;
    ubyte  a;
    float  uv0_u;
    float  uv0_v;
    float  uv1_u;
    float  uv1_v;
    uint32 uv2_u;
    uint32 uv2_v;
};

struct VertexBuffer2Channel4 {
    ubyte  r;
    ubyte  g;
    ubyte  b;
    ubyte  a;
    float  uv0_u;
    float  uv0_v;
    float  uv1_u;
    float  uv1_v;
    uint32 uv2_u;
    uint32 uv2_v;
    uint32 uv3_u;
    uint32 uv3_v;
};

struct UnknStruct {
    ubyte unkn[16];
};

struct RootNode {
    uint32 pad0;        // Always 00 00 00 00
    Assert(pad0 == 0);
    uint32 nodeType;    // 1 = Root, 2 = Bone, 4 = Mesh
    uint32 flags;       // FF 00 40 00
    //Assert(flags == 4194559);
    ubyte  pad[32];
    uint32 featureMask;
    ubyte  todo[564 - 48];
};

//------------------------------------------------

struct ModlDat {
    uint32  maybeVersion;
    Assert(maybeVersion == 4);
    GUID    guid;
    uint32  poolTotalSize;
    PoolDirectory poolDir;

    SubHead meshInfoHdr;
    SubHead materialNamesHdr;
    SubHead bufferTopologyHdr;
    SubHead indexBufferHdr;
    SubHead vertexBuffer1Hdr;
    SubHead vertexBuffer2Hdr;

    ObjectEntry rootObjectEntry;
    ObjectEntry meshInfoEntries[meshInfoHdr.elementCount];
    ObjectEntry materialNamesEntries[materialNamesHdr.elementCount];
    ObjectEntry bufferTopologyEntries[bufferTopologyHdr.elementCount];
    ObjectEntry indexBufferEntries[indexBufferHdr.elementCount];
    ObjectEntry vertexBuffer1Entries[vertexBuffer1Hdr.elementCount];

    //FSeek(poolTotalSize);
    //ubyte unknHeader[56];
    struct UnknStruct unknStruct[poolDir.meshCount];

    FSeek(meshInfoHdr.offset);
    struct MeshInfoDat meshInfoDat;

    FSeek(materialNamesHdr.offset);
    struct MaterialNamesDat materialNamesDat;


    FSeek(bufferTopologyHdr.offset);
    struct BufferTopologyDat bufferTopologyDat;

    FSeek(indexBufferHdr.offset);
    struct IndexBufferDat indexBufferDat;

    FSeek(vertexBuffer1Hdr.offset);
    struct VertexBuffer1Dat vertexBuffer1Dat[vertexBuffer1Hdr.size / 24]; // divide by stride. TODO.

    FSeek(vertexBuffer2Hdr.offset);
    ubyte  vertexBuffer2Dat[vertexBuffer2Hdr.size];
    // TODO divide by stride each mesh.
    // struct VertexBuffer2Channel1 vertexBuffer2Dat[vertexBuffer2Hdr.size / 12]; // sometimes this without additional uint32s
    // struct VertexBuffer2Channel2 vertexBuffer2Dat[vertexBuffer2Hdr.size / 20]; // sometimes this with additional uint32s
    // struct VertexBuffer2Channel4 vertexBuffer2Dat[vertexBuffer2Hdr.size / 36]; // sometimes this with additional uint32s

    FSeek(modlHdr.size + 32);
};

struct MeshInfoDat {
    struct RootNode rootNode;
    
    // Temporal solution untill it is found how to parse it correctly.
    local uint64 startPos = FTell();
    local TFindResults r;
    r = FindAll(0x04003000);
    for(int i = 0; i < r.count; i++ ) {
        FSeek(r.start[i]);
        SubMeshHeader subMeshHeader;
    }
    // Temporal solution untill it is found how to parse it correctly.
    // Skip 52 bytes. Had no luck doing it with regex.
    FSeek(FindFirst("18000000????????????????????????????????????????????????????????????????????????????????????????????????????????18000000,h", true, false, FINDMETHOD_WILDCARDS));
    while(ReadInt()==0x18)
        MeshBufferMap meshBufferMap;

    FSeek(meshInfoHdr.size + startPos);
 };

struct MaterialNamesDat {
    local uint64 startPos = FTell();
    while (ReadByte() == 0x0)
        FSkip(1);
    while (ReadByte() != 0x0)
        struct NameArr {
            string name;
        } nameArr;
    FSeek(materialNamesHdr.size + startPos);
};

struct IndexBufferDat {
    if (bufferTopologyDat.faces_buf_u16_or_u32 == 0 && bufferTopologyDat.faces_buf_list_or_strip == 0)
        struct FacesU32List faces_u32_list[indexBufferHdr.size / 12];

    if (bufferTopologyDat.faces_buf_u16_or_u32 == 1 && bufferTopologyDat.faces_buf_list_or_strip == 0)
        struct FacesU16List faces_u16_list[indexBufferHdr.size / 6];

    if (bufferTopologyDat.faces_buf_u16_or_u32 == 0 && bufferTopologyDat.faces_buf_list_or_strip == 1)
        uint32 faces_u32_strip[indexBufferHdr.size / 4];

    if (bufferTopologyDat.faces_buf_u16_or_u32 == 1 && bufferTopologyDat.faces_buf_list_or_strip == 1)
        uint16 faces_u16_strip[indexBufferHdr.size / 2];
};

//------------------------------------------------

Head    modlHdr;
ModlDat modlDat;
Head    dpndHdr;
Assert(dpndHdr.magic == "DPND", "Not Silent Hill: Homecoming DPND file");
DpndDat dpndDat;
