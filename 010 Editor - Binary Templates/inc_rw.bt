//------------------------------------------------
//--- 010 Editor v14.0 Binary Template
//
//      File: inc_rw.bt
//   Authors: Laurynas ZubaviÄius (Sparagas)
//   Purpose: RenderWare Binary Stream
//  Category: Include file
//------------------------------------------------

#include "vector.bt"
#include "color.bt"


string IDUnpackVersion(uint32 libid) {
    int ver;
    if (libid & 0xFFFF0000)
        ver = (libid >> 14 & 0x3FF00) + 0x30000 |
              (libid >> 16 & 0x3F);
    else
        ver = libid << 8;
    string s;   
    SPrintf(s, "0x%x", ver);
    return s;
    }

enum <uint32> GeometryAttributes {
    none                   = 0x0,
    Triangle               = 0x1,
    VertexPositions        = 0x2,
    TextCoords             = 0x4,
    VertexColors           = 0x8,
    Normals                = 0x10,
    Lights                 = 0x20,
    ModulateMaterialColors = 0x40,
    MultipleTextCoords     = 0x80,

    NativeGeometry = 0x1000000,
    NativeInstance = 0x2000000,
    SectorsOverlap = 0x40000000
};

enum <uint32> RwId {
    // Core
    STRUCT          = 0x1,
    STRING          = 0x2,
    EXTENSION       = 0x3,
    TEXTURE         = 0x6,
    MATERIAL        = 0x7,
    MATERIAL_LIST   = 0x8,
    ATOMIC_SECTION  = 0x9,
    PLANE_SECTION   = 0xA,
    WORLD           = 0xB,
    RIGHT_TO_RENDER = 0x1F,
    // Toolkit
    PVS_PLG           = 0x106,
    PS2_MIPMAP_VAL    = 0x110,
    COLLISION_PLG     = 0x11D,
    USER_DATA_PLG     = 0x11F,
    GEOMETRIC_PVS_PLG = 0x12A,
    // World
    BIN_MESH_PLG    = 0x50E,
    NATIVE_DATA_PLG = 0x510,
    UNK_WORLD_PLG   = 0x511
};

typedef struct {
    RwId   id;
    uint32 len;
    uint32 ver <read=IDUnpackVersion>;
} RwHeader <read=EnumToString(id)>;

// generic and should be replaced
struct RwStruct {
    RwHeader rw_header;
    ubyte    data[rw_header.len];
};

struct RwString {
    RwHeader rw_header;
    char     str[rw_header.len];
};

struct RWStructExtension {
    RwHeader rw_header;
    switch (rw_header.id) {
        case 0x1F  : RightToRender(); break;
        case 0x106 : PvsPlg(); break;
        case 0x110 : SkyMipmapVal(); break;
        case 0x11D : CollisionPlg(); break;
        case 0x11F : UserDataPlg(); break;
        case 0x12A : GeometricPvsPlg(); break;
        case 0x50E : BinMeshPlg(); break;
        case 0x510 : NativeDataPlg(); break;
        case 0x511 : UnkWorldPlg(); break;
        default    : ubyte  unk[rw_header.len];
    }
};

struct RwExtension {
    RwHeader rw_header;

    local int len = rw_header.len;
    while (len) {
        RWStructExtension rw_struct;
        len = len - sizeof(rw_struct);
    }
};

struct RwStructTexture {
    RwHeader rw_header;
    uint32   filtering : 8;
    uint32   u         : 4;
    uint32   v         : 4;
    uint32   mipmap    : 1;
};

struct RwTexture {
    RwHeader        rw_header;
    RwStructTexture rw_struct;
    RwString        rw_tex_name;
    RwString        rw_tex_alpha_name;
    RwExtension     rw_extension;
};

struct RwStructMaterial {
    RwHeader rw_header;
    int32    flags; // unused
    RGBA     color;
    int32    unk; // marked as unused, but it is used
    int32    isTextured;
    // if version > 0x30400 // but I have 0x30400 and it is still present
        float ambient;
        float specular;
        float diffuse;
};

struct RwMaterial {
    RwHeader         rw_header;
    RwStructMaterial rw_struct;

    if (rw_struct.isTextured)
        RwTexture rw_texture;

    RwExtension rw_extension;
};

struct RwStructMaterialList {
    RwHeader rw_header;
    uint32   num_material;
     int32   material_idx[num_material];
};

struct RwMaterialList {
    RwHeader             rw_header;
    RwStructMaterialList rw_struct;
    
    local int i, num_unique_material = 0;
    for (i = 0; i < rw_struct.num_material; i++)
        if (rw_struct.material_idx[i] == -1)
            num_unique_material++;
    
    RwMaterial rw_material[num_unique_material] <optimize=false>;
};

struct RwStructAtomicSection {
    RwHeader  rw_header;
    uint32    mat_list_window_base;
    uint32    num_triangles; // need to test if it is realy triangles
    uint32    num_vertices;
    f32x3_geo bbox_min;
    f32x3_geo bbox_max;
    uint32    unk_coll_sector_present; // sometimes it looks like float
    uint32    unused;

    if (rw_header.len > 11*4)
        ubyte data[rw_header.len - 11*4]; // debug - some times there are buffers inside
};

struct RwAtomicSection {
    RwHeader              rw_header;
    RwStructAtomicSection rw_struct;
    RwExtension           rw_extension;
};

struct RwStructPlaneSection {
    RwHeader rw_header;
    uint32   unk_type;
    float    unk_value;
    int32    is_left_atomic;
    int32    is_right_atomic;
    float    unk_left_value;
    float    unk_right_value;
};

struct RwPlaneSection; // forward declaration for recursive structure
struct RwPlaneSection {
    RwHeader             rw_header;
    RwStructPlaneSection rw_struct;
    
    if (rw_struct.is_left_atomic)
        RwAtomicSection left_atomic_section;
    else
        RwPlaneSection  left_plane_section;

    if (rw_struct.is_right_atomic)
        RwAtomicSection right_atomic_section;
    else
        RwPlaneSection  right_plane_section;  
};

struct RwStructWorld {
    RwHeader   rw_header;
    uint32     is_world_root;
    f32x3_geo  inverse_origin;

    if (rw_header.len == 52)
        f32x3_geo bbox_max_center; // need example to test it

    uint32 num_triangles; // need to test if realy triangles
    uint32 num_vertices;
    uint32 num_plane_sectors;
    uint32 num_atomic_sectors;
    uint32 unk_col_sector_size;
    uint32 geometry_attributes; // TODO

    if (rw_header.len == 64) {
        f32x3_geo bbox_max;
        f32x3_geo bbox_min;
    }
};

struct RwWorld {
    RwHeader       rw_header;
    RwStructWorld  rw_struct;
    RwMaterialList rw_material_list;
    
    if (rw_struct.is_world_root)
        RwAtomicSection rw_atomic_section;
    else
        RwPlaneSection  rw_plane_section;

    RwExtension rw_extension;
};

void RightToRender() {
    uint32 rw_plugin_id;  // maybe RWId?
    uint32 extra_data;
}

void PvsPlg() {
    ubyte unk_pvs_data[rw_header.len];
}

void SkyMipmapVal() { // Sky is a codename for PS2
    uint32 k_l_value; // TODO
}

void CollisionPlg() {
    ubyte unk_collission_data[rw_header.len];
}

enum <uint32> DataType {
    integer_32 = 1,
    float_32   = 2,
    str_ascii  = 3
};

struct EntryUserDataPlg {
    uint32   len_str;
    char     str[len_str];
    DataType data_type;
    uint32   num_obj;
    
    if (data_type == integer_32)
        uint32 u32_obj[num_obj];
    else if (data_type == float_32)
        float  f32_obj[num_obj];
    else if (data_type == str_ascii) {
        uint32 len_obj;
        char   str_obj[len_obj];
    }
};

void UserDataPlg() {
    uint32           num_entry;
    EntryUserDataPlg entry[num_entry] <optimize=false>;
}

void GeometricPvsPlg() {
    uint32 unk_id;
    uint32 len;
    if (len) {
        uint32 unk;
        ubyte  unk_entry[len];
    }
}

struct IndicesBinMeshPlg(int type) {
    uint32 num_indices;
    uint32 material_index;
    if (type == 16)
        uint16 u16_vert_idx[num_indices];
    else if (type == 32)
        uint32 u32_vert_idx[num_indices];
};

void BinMeshPlg() {
    uint32 is_tri_strip;
    uint32 num_mesh;
    uint32 num_total_indices;
    
    if (num_mesh == 0) // totaly empty
        return;
    if (rw_header.len - 12 == num_mesh * 8) // headers with no data
        IndicesBinMeshPlg mesh_idx_hdr(0)[num_mesh] <optimize=false>;

    else if (rw_header.len - 12 == num_mesh * 8 + num_total_indices * 2) // headers with uint16 data
        IndicesBinMeshPlg mesh_idx_u16(16)[num_mesh] <optimize=false>;

    else if (rw_header.len - 12 == num_mesh * 8 + num_total_indices * 4) // headers with uint32 data
        IndicesBinMeshPlg mesh_idx_u32(32)[num_mesh] <optimize=false>;
}

struct Ps2Data {
    uint32 size;
    uint32 unk_noPointers;
    ubyte  vif_codes[size];
};

struct RwStructNativeDataPlg {
    RwHeader rw_header;
    uint32   platform;
    // it should be in a loop
    if (rw_header.len-4) {
        Ps2Data ps2_data[rw_world.rw_material_list.rw_struct.num_material] <optimize=false>;
    }
};

void NativeDataPlg() {
    RwStructNativeDataPlg rw_struct;
}

void UnkWorldPlg() {
    ubyte unk_world_data[rw_header.len];
}
